---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by daiyi.
---战斗摄像机组件
--- DateTime: 2019/4/22 13:35
---
local BattleCameraComponent = BaseClass("BattleCameraComponent", Component)
local base = Component

if CameraType == nil then
    CameraType = {
        None = 0,   
        Center = 1, --中间摄像机
        Left = 2,   --左边摄像机
        Right = 3,  --右边摄像机
        Awake = 4,  --觉醒摄像机
        CutIn = 5,  --CutIn摄像机
        CurCamera = 3 -- 当前摄像机  进去默认是右边的摄像机
    }
end

local awakenCenter = Vector3.New(6,2.48,-6.65)
local rightLeftOffset = Vector3.New(0,11.5,-40)--Vector3.New(0,24,-95)   -- -12.5   55
local followOffset = Vector3.New(0,11.5,-40) --Vector3.New(0,24,-95) --跟随偏移
local centerCameraOffset = Vector3.New(0,17.8,-29.5)
local awakenFollowOffset = Vector3.New(0,2.48,-6.7) --觉醒跟随偏移 -88.3Vector3.New(0,24,-95)
local leftCenterPos = Vector3.New(0, 0, 0)
local rightCenterPos = Vector3.New(0, 0, 0)
local rightInitPos = Vector3.New(3.6,14,-50)--Vector3.New(3.6, 3.78, -8.8)
local vectorZero = Vector3.New(0, 0, 0)
local cameraFollow

local centerFarCameraFieldOfView = 14.5 --摄像机的FieldOfView

local shakeDurationAwaken = 0.5 --觉醒震动时间
local shakeStrengthAwaken = 0.2 --觉醒震动强度
local shakeDuration = 0.3  --震动时间
local shakeStrength = 0.15 --震动强度

local function Awake(self)
    base.Awake(self)
    
    self.fieldPara = 1920 / 1080 / (CS.UnityEngine.Screen.width / CS.UnityEngine.Screen.height)
    
    self.battle_component = Game.Scene:GetComponent("BattleComponent")
    local battleCameraRoot = GameObjectPool:GetInstance():CoGetGameObjectAsync("Scene/Common/BattleCamera.prefab")
    battleCameraRoot.transform:SetParent(GameObject.Find("SceneRoot").transform,false)
    
    self.InfoUICamera = battleCameraRoot.transform:Find("InfoUICamera"):GetComponent(typeof(Camera))
    self.ToolUICamera = battleCameraRoot.transform:Find("ToolUICamera"):GetComponent(typeof(Camera))
    self.AwakenUICamera = battleCameraRoot.transform:Find("AwakenUICamera"):GetComponent(typeof(Camera))
    self.left_close_camera = battleCameraRoot.transform:Find("LeftCloseCamera"):GetComponent(typeof(Camera))
    self.right_close_camera = battleCameraRoot.transform:Find("RightCloseCamera"):GetComponent(typeof(Camera))
    self.center_far_camera = battleCameraRoot.transform:Find("CenterFarCamera"):GetComponent(typeof(Camera))
    self.awaken_skill_camera = battleCameraRoot.transform:Find("AwakenSkillCamera"):GetComponent(typeof(Camera))
    self.cut_in_camera = battleCameraRoot.transform:Find("CutInCamera"):GetComponent(typeof(Camera))
    self.map_camera = battleCameraRoot.transform:Find("MapCamera"):GetComponent(typeof(Camera))
    
    self.left_close_camera_color = self.left_close_camera.backgroundColor
    self.right_close_camera_color = self.right_close_camera.backgroundColor

    CameraType.CurCamera = CameraType.Right
end

-- 优化：中间摄像机，位置始终不动，这里可以根据实际人数来看全局任务
local function KeepCenter(self)
    --self.LeftGroup = self.battle_component:SortByRowAndLine(self.battle_component:GetGroupUnits(MatrixGroup.Enemy))
    --self.RightGroup = self.battle_component:SortByRowAndLine(self.battle_component:GetGroupUnits(MatrixGroup.Friend))
    --if self.LeftGroup ~= nil and #self.LeftGroup ~= 0 and self.RightGroup ~= nil and #self.RightGroup ~= 0 then
    --    local leftRow = self.LeftGroup[#self.LeftGroup]:GetComponent("SsUnitMatrixComponent").Row
    --    local rightRow = self.RightGroup[#self.RightGroup]:GetComponent("SsUnitMatrixComponent").Row
    --    local tnf = self.center_far_camera.transform
    --    local x = (rightRow - leftRow) * 1.97 / 2
    --    tnf.localPosition = Vector3.New(x, tnf.localPosition.y, tnf.localPosition.z)
    --end
end

local function KeepLeftCenter(self)
    if self.left_close_camera == nil or self.left_close_camera.gameObject.activeSelf then return end
    if Vector3.Distance(self.left_close_camera.transform.localPosition, leftCenterPos) < 0.05 then return end
    local matrix_component = Game.Scene:GetComponent("MatrixComponent")
    if matrix_component == nil then return end
    if leftCenterPos == vectorZero then
        leftCenterPos = matrix_component.LMM.transform.position + rightLeftOffset
    end
    self.left_close_camera.transform.localPosition = leftCenterPos
end

local function KeepRightCenter(self)
    if self.right_close_camera == nil or self.right_close_camera.gameObject.activeSelf then return end
    if Vector3.Distance(self.right_close_camera.transform.localPosition, rightCenterPos) < 0.05 then return end
    local matrix_component = Game.Scene:GetComponent("MatrixComponent")
    if matrix_component == nil then return end
    if rightCenterPos == vectorZero then
        rightCenterPos = matrix_component.RMM.transform.position + rightLeftOffset
    end
    self.right_close_camera.transform.localPosition = rightCenterPos
end

local function SwitchCamera(self, type)
    self.left_close_camera.gameObject:SetActive(false)
    self.right_close_camera.gameObject:SetActive(false)
    self.center_far_camera.gameObject:SetActive(false)
    self.awaken_skill_camera.gameObject:SetActive(false)
    if type == CameraType.Center then
        self.center_far_camera.gameObject:SetActive(true)
        CameraType.CurCamera = CameraType.Center
    elseif type == CameraType.Left then
        self.left_close_camera.gameObject:SetActive(true)
        CameraType.CurCamera = CameraType.Left
    elseif type == CameraType.Right then
        self.right_close_camera.gameObject:SetActive(true)
        CameraType.CurCamera = CameraType.Right
    elseif type == CameraType.Awake then
        self.awaken_skill_camera.gameObject:SetActive(true)
        CameraType.CurCamera = CameraType.Awake
    end
end

local function GetCamera(self, type)
    if type == CameraType.Center then
        return self.center_far_camera
    elseif type == CameraType.Left then
        return self.left_close_camera
    elseif type == CameraType.Right then
        return self.right_close_camera
    elseif type == CameraType.Awake then
        return self.awaken_skill_camera
    end
    Logger.LogError("Camera is nil")
    return nil
end

local function Show(self, callBack)
    self.right_close_camera.transform.localPosition = rightInitPos
    SwitchCamera(self, CameraType.Right)
    DOTween.Sequence()
           :AppendInterval(0.6)
           :Append(self.right_close_camera.transform:DOMoveX(-1.5, 2))
           :AppendCallback(function ()
            DOTween.Sequence()
                   :Append(self.center_far_camera:DOFieldOfView(11 * self.fieldPara,0))
                   :Append(self.center_far_camera:DOFieldOfView(centerFarCameraFieldOfView * self.fieldPara, 0.4))
                   :InsertCallback(0.2,function ()
                    SwitchCamera(self, CameraType.Center)
                    KeepCenter(self)
                    KeepLeftCenter(self)
                    KeepRightCenter(self)
                    end):AppendCallback(callBack)
            end)
end

local function LateUpdate(self)
    xpcall(function ()
        local cam = GetCamera(self, CameraType.CurCamera)
        if cam ~= nil and cam.gameObject.activeSelf and cameraFollow ~= nil and not IsNull(cameraFollow) then
            cam.transform:DOKill()
            cam.transform:DOMove(cameraFollow.position + followOffset, 0.2)
        end
        if self.map_camera ~= nil then
            if cam == nil or cam == CameraType.Awake then
                self.map_camera.gameObject:SetActive(false)
            else
                self.map_camera.gameObject:SetActive(true)
                self.map_camera.transform.position = cam.transform.position
                self.map_camera.transform.rotation = cam.transform.rotation;
                self.map_camera.transform.localScale = cam.transform.localScale;
                self.map_camera.fieldOfView = cam.fieldOfView
            end
        end
    end, function (msg) 
        Logger.LogError("BattleCameraComponent:LateUpdate"..msg)
    end)
end

-- 摄像机切换固定点
local function SwitchCameraByPos(self, type, pos, delay, duration)
    cameraFollow = nil
    
    -- 如果是中间摄像机
    if type == CameraType.Center then
        KeepCenter(self)
        if self.center_far_camera == nil then
            return
        end

        if not self.center_far_camera.gameObject.activeSelf then
            self.center_far_camera:DOFieldOfView(9 * self.fieldPara, 0)
            self.center_far_camera:DOFieldOfView(centerFarCameraFieldOfView * self.fieldPara, 0.5)
        end
        SwitchCamera(self, type)
        return
    end
    
    -- 左右摄像机和觉醒摄像机偏移不同
    local offset = type == CameraType.Awake and awakenFollowOffset or rightLeftOffset
    
    -- 摄像机不同边显示直接切换， 同边显示缓动
    local cameraSwitch = GetCamera(self, type)
    assert(not IsNull(cameraSwitch))

    local time = 0
    local targetPos = pos + offset
    local speed = 5
    if CameraType.CurCamera == type and CameraType.CurCamera ~= CameraType.Awake then
        local dis = Vector3.Distance(cameraSwitch.transform.localPosition, targetPos)
        time = dis / speed
    elseif duration ~= nil then
        time = duration
        cameraSwitch.transform.localPosition = GetCamera(self, CameraType.CurCamera).transform.localPosition
    end

    local func = function ()
        SwitchCamera(self, type)
        if pos ~= nil then
            cameraSwitch.transform:DOKill()
            cameraSwitch.transform:DOMove(targetPos, time)
            if type == CameraType.Awake then
                cameraSwitch.transform.localEulerAngles = Vector3.New(0, 0, 0)
            end
        end
    end

    if delay == nil or delay <= 0 then
        func()
        return
    end

    coroutine.start(function()
        coroutine.waitforseconds(delay)
        func()
    end)
end

-- 摄像机跟随
local function SwitchCameraByTnf(self, type, tnf, delay)
    local cam = GetCamera(self, CameraType.CurCamera)
    local cameraSwitch = GetCamera(self, type)
    assert(not IsNull(cameraSwitch) and not IsNull(cam))
    
    local func = function ()
        cameraFollow = tnf
        SwitchCamera(self, type)
    end

    if delay == nil or delay <= 0 then
        func()
        return
    end

    coroutine.start(function()
        coroutine.waitforseconds(delay)
        func()
    end)
end

local function LeftAwakeSet(self) --释放觉醒时 摄像机屏蔽场景
    self.left_close_camera.clearFlags = 2
    self.left_close_camera.backgroundColor = Color.New(0,0,0)
    --CSUtil.SetCameraCullingMask(self.left_close_camera,8,false)
    self.map_camera.gameObject:SetActive(false)
end

local function DeLeftAwakeSet(self) --觉醒释放完  摄像机取消屏蔽场景
    self.left_close_camera.clearFlags = 3
    self.left_close_camera.backgroundColor = self.left_close_camera_color
    --CSUtil.SetCameraCullingMask(self.left_close_camera,8,true)
    self.map_camera.gameObject:SetActive(true)
end

local function RightAwakeSet(self) --释放觉醒时 摄像机屏蔽场景
    self.right_close_camera.clearFlags = 2
    self.right_close_camera.backgroundColor = Color.New(0,0,0)
    --CSUtil.SetCameraCullingMask(self.right_close_camera,8,false)
    self.map_camera.gameObject:SetActive(false)
end

local function DeRightAwakeSet(self) --觉醒释放完  摄像机取消屏蔽场景
    self.right_close_camera.clearFlags = 3
    self.right_close_camera.backgroundColor = self.right_close_camera_color
    --CSUtil.SetCameraCullingMask(self.right_close_camera,8,true)
    self.map_camera.gameObject:SetActive(true)
end

local function ResetAwakenCamera(self)
    self.awaken_skill_camera.transform.localPosition = awakenCenter
end
-------------------------------觉醒摄像机 End --------------------------------

-------------------------------CutIn摄像机--------------------------------
local function CutinCameraON(self, pos)
    self.cut_in_camera.gameObject:SetActive(true)
    if pos == true then -- 战阵技能
        self.cut_in_camera.transform.position = Vector3.New(0, 0, -12)
        self.cut_in_camera.transform.localEulerAngles = self.awaken_skill_camera.transform.localEulerAngles
        self.cut_in_camera.orthographic = false
    else
        self.cut_in_camera.orthographic = true
        self.cut_in_camera.transform.position = Vector3.New(0, 0, -20)
        self.cut_in_camera.transform.localEulerAngles = vectorZero
    end
end

local function CutinCameraOFF(self)
    self.cut_in_camera.gameObject:SetActive(false)
end

local function ShakeCutIn(self,duration,strength)
    self.cut_in_camera:DOShakePosition(duration,strength)
end
-------------------------------CutIn摄像机--------------------------------

--摄像机震动
local function ShakeCamera(self, zSkill)
    local left_camera = GetCamera(self, CameraType.Left)
    local right_camera = GetCamera(self, CameraType.Right)
    local cur_camera
    if left_camera.gameObject.activeSelf then
        cur_camera = left_camera
    elseif right_camera.gameObject.activeSelf then
        cur_camera = right_camera
    end

    if not cur_camera then return end

    if zSkill.IsAwaken == 1 then
        cur_camera:DOShakePosition(shakeDurationAwaken, shakeStrengthAwaken)
    else
        cur_camera:DOShakePosition(shakeDuration, shakeStrength)
    end
end

local function ShakeCurCamera(self,duration,strength)
    local cam = GetCamera(self, CameraType.CurCamera)
    cam:DOShakePosition(duration, strength)
end

local function IsCurCamera(self,camera)
    return camera.name == GetCamera(self, CameraType.CurCamera).name
end

local function SetCurCameraPos(self,pos,time)
    local camera = GetCamera(self, CameraType.CurCamera)
    camera.transform:DOMove(pos,time)
end

local function SetCurCameraLocalPos(self, pos, time)
    local camera = GetCamera(self, CameraType.CurCamera)
    camera.transform:DOLocalMove(pos,time)
end

local function SetCurCameraRot(self,rot,time)
    local camera = GetCamera(self, CameraType.CurCamera)
    rot=camera.transform.localEulerAngles+rot
    camera.transform:DOLocalRotate(rot,time)
end

local function SetCurCameraField(self, val, time)
    local camera = GetCamera(self, CameraType.CurCamera)
    val = camera.fieldOfView + val * self.fieldPara
    camera:DOFieldOfView(val, time)
end

local function SetCenterCameraOffset(self,offset)
    if offset == nil then
        self.center_far_camera.transform.localPosition = centerCameraOffset
    else
        self.center_far_camera.transform.localPosition = Vector3.New(offset[1],offset[2],offset[3])
    end
end

local function Dispose(self)
    base.Dispose(self)
    cameraFollow = nil
end

BattleCameraComponent.Awake = Awake
BattleCameraComponent.LateUpdate = LateUpdate
BattleCameraComponent.GetCamera = GetCamera
BattleCameraComponent.ShakeCamera = ShakeCamera
BattleCameraComponent.IsCurCamera = IsCurCamera
BattleCameraComponent.ShakeCutIn = ShakeCutIn
BattleCameraComponent.SwitchCameraByPos = SwitchCameraByPos
BattleCameraComponent.SwitchCameraByTnf = SwitchCameraByTnf 
BattleCameraComponent.LeftAwakeSet = LeftAwakeSet
BattleCameraComponent.DeLeftAwakeSet =DeLeftAwakeSet
BattleCameraComponent.ResetAwakenCamera = ResetAwakenCamera
BattleCameraComponent.SetCenterCameraOffset = SetCenterCameraOffset
BattleCameraComponent.Dispose = Dispose
BattleCameraComponent.CutinCameraON= CutinCameraON
BattleCameraComponent.CutinCameraOFF= CutinCameraOFF
BattleCameraComponent.SetCurCameraPos=SetCurCameraPos --
BattleCameraComponent.SetCurCameraLocalPos=SetCurCameraLocalPos --
BattleCameraComponent.RightAwakeSet=RightAwakeSet
BattleCameraComponent.DeRightAwakeSet=DeRightAwakeSet
BattleCameraComponent.ShakeCurCamera=ShakeCurCamera
BattleCameraComponent.SetCurCameraRot=SetCurCameraRot
BattleCameraComponent.Show=Show
BattleCameraComponent.SetCurCameraField=SetCurCameraField
return BattleCameraComponent