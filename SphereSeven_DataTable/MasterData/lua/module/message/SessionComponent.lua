---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by daiyi.
--- DateTime: 2019/4/10 0:56
---
import(".OuterOpcode")
import(".ErrorCode")
local protoMessages = require("Protobuf.proto_messages")

if LongSessionState == nil then
    LongSessionState = {
        Connected = 1, -- 登录状态
        Connecting = 2, -- 正在连接状态
        DisConnected = 3, -- 断开连接状态
        ReConnecting = 4, -- 正在重连状态
    }
end
if LoadMode == nil then
    LoadMode = {
        Cat = 1,
        Mask = 2,
    }
end
---@class SessionComponent
local SessionComponent = BaseClass("SessionComponent", Component)
local base = Component

local function Awake(self)
    base.Awake(self)
    local pbta = ResourcesManager:GetInstance():CoLoadAsync("Pb/OuterMessage.pb.bytes", typeof(CS.UnityEngine.TextAsset))
    assert(pb.load(pbta.bytes))
    local newPbta = ResourcesManager:GetInstance():CoLoadAsync("Pb/NewPb.bytes", typeof(CS.UnityEngine.TextAsset))
    assert(pb.load(newPbta.bytes))

    self.longSession = nil
    self.loginAddress = ChannelManager:GetInstance():GetAddress()
    self.loginKey = nil
    self.permission = nil

    self.forceOffLine = 0 -- 0手动退出  1被挤下线  2被服务器踢了
    Game.Scene.Session = self
    self.longSessionState = LongSessionState.DisConnected
    self.loadingGameError = nil -- 读取玩家数据错误
    self.msgCache = Queue.New()
    self.activeQueue = Queue.New()
    self.deactiveQueue = Queue.New()
    self.catMap = {} -- key - {count, msgList}
    self.DateTime = 0 -- 开服时间
    self.ServerInfoList = {}
    self.reConnTimes = 0 -- 重连拉取数据次数

    self.serverAddress =  "0"
    self.serverPort =  "0"
end

-- 游戏遮罩
local function Update(self)
    if self.activeQueue == nil or self.deactiveQueue == nil then
        return
    end
    if self.activeQueue:size() > 0 then
        local wnd = UIManager:GetInstance():GetWindow(UIWindowNames.UILoad, true)
        --- print cat message
        local activeData = self.activeQueue:dequeue()

        if self.catMap[activeData.key] == nil then
            self.catMap[activeData.key] = 1
        else
            self.catMap[activeData.key] = self.catMap[activeData.key] + 1
        end
        if wnd == nil then
            UIManager:GetInstance():OpenWindow(UIWindowNames.UILoad, activeData)
        else
            wnd.View:ActiveLoading(activeData)
        end
    end
    if self.deactiveQueue:size() > 0 then
        local deactiveData = self.deactiveQueue:dequeue()
        --- print cat message
        if self.catMap[deactiveData.key] == nil then
            self.catMap[deactiveData.key] = 0
        else
            self.catMap[deactiveData.key] = self.catMap[deactiveData.key] - 1
        end
        local wnd = UIManager:GetInstance():GetWindow(UIWindowNames.UILoad, true)
        if wnd ~= nil then
            wnd.View:DeActiveLoading(deactiveData)
        end
    end
end

-- 显示load界面
SessionComponent.ActiveLoad = function (self, message, loadMode, key)
    if message == nil then
        message = ""
    end
    loadMode = loadMode == nil and LoadMode.Cat or loadMode
    if key == nil then
        key = "None"
    end
    self.activeQueue:enqueue({ message = message, loadMode = loadMode, key = key })
end

-- 关闭load界面
SessionComponent.DeActiveLoad = function(self, loadMode, key)
    loadMode = loadMode == nil and LoadMode.Cat or loadMode
    if key == nil then
        key = "None"
    end
    self.deactiveQueue:enqueue({ loadMode = loadMode, key = key })
end

-- socket连接
SessionComponent.Connect = function(self, session, ipEndPortStr, onConn, onError)
    local splits = string.split(ipEndPortStr,":")
    local ip, port = splits[1], splits[2]
    assert(ip)
    assert(port)
    session:Connect(ip, port, onConn, onError)
end

-- 《弃用》仅用于用户注册，注册账号，是一个短连接
SessionComponent.Register = function(self, username, password, onRegister, onError)
end

-- 《弃用》老版本登录：用于用户登录，验证账号，是一个短连接
SessionComponent.OldLogin = function(self, username, password, onLogin, onError)
end

SessionComponent.ServerState = function(self, uid, onSuccess, onError)
    local session = Game.Registry:NewObject(Config.SessionClassName)
    self:Connect(session, self.loginAddress, function ()
        -- 请求服务器状态
        local r2CLogin = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_ServersState,{ AccountId = uid})
        if r2CLogin.Error ~= ErrorCode.ERR_Success then
            if onError ~= nil then onError(r2CLogin.Error) end
        else
            self.ServerInfoList = r2CLogin.ServerInfoList
            if onSuccess ~= nil then onSuccess(r2CLogin) end
        end
        session:Dispose()
    end, function(errorCode)
        if onError ~= nil then onError(errorCode) end
        session:Dispose()
    end)
end

-- 用于用户登录，验证账号，是一个短连接
---@param self SessionComponent
SessionComponent.Login = function(self, uid, password, username, onLogin, onError)
    Logger.Log("Login Uid: " .. uid .. ", Username: ".. username)
    if ChannelManager:GetInstance():IsSdk() then
        PlayerPrefs.SetString("uid" .. ClientData:GetInstance().package_name, uid)
    end
    local session = Game.Registry:NewObject(Config.SessionClassName)

    -- self:Connect(session, self.loginAddress, function ()
    --     -- 请求登录key
    --     local rkey, rIv = ChannelManager:GetInstance():GetRKey()
    --     local deviceCode = username
    --     password = CS.AESHelper.EnCode(password,rkey,rIv)
    --     username = CS.AESHelper.EnCode(username,rkey,rIv)
    --     local r2CLogin = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Login,
    --             { UId = uid, Password = password, Username = username,DeviceCode = deviceCode, Sig = CS.GameChannel.ChannelManager.instance.signature})
    --     if r2CLogin.Error ~= ErrorCode.ERR_Success then
    --         if onError ~= nil then onError(r2CLogin.Error) end
    --     else
    --         self.loginKey = r2CLogin.Key
    --         self.permission = r2CLogin.Permission

    --         local client_data = ClientData:GetInstance()
    --         -- 创建角色埋点
    --         if client_data.uid == nil or string.IsNullOrEmpty(tostring(client_data.uid)) then
    --             client_data:SetAccountInfo(r2CLogin.UId, r2CLogin.Password)
    --             ChannelManager:GetInstance():CommonCallback(GameEvent.CreateRole)
    --         end
    --         client_data:SetAccountInfo(r2CLogin.UId, r2CLogin.Password)
    --         TapDB.setUser(tostring(r2CLogin.UId));
    --         -- 获取服务器状态
    --         local r2CServers = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Servers,{ Key = r2CLogin.Key })
    --         if r2CServers.Error ~= ErrorCode.ERR_Success then
    --             if onError ~= nil then onError(r2CServers.Error) end
    --         else
    --             self.ServerInfoList = r2CServers.ServerInfoList
    --             if onLogin ~= nil then onLogin(r2CServers) end
    --         end
    --     end
    --     session:Dispose()
    -- end, function(errorCode)
    --     if onError ~= nil then onError(errorCode) end
    --     session:Dispose()
    -- end)


    local rkey, rIv = ChannelManager:GetInstance():GetRKey()
    local deviceCode = username
    password = CS.AESHelper.EnCode(password,rkey,rIv)
    username = CS.AESHelper.EnCode(username,rkey,rIv)

    local r2CLogin = 
    {
        RpcId = 0,
        Error = 0,
        Key = "key",
        UId = PlayerPrefs.GetString("uid"..ClientData:GetInstance().package_name),
        Password = PlayerPrefs.GetString("password"..ClientData:GetInstance().package_name),
        Permission = 0,
        State = 0,
    }    

    local userid --= CS.flyingSDK.GetSdkUserId()
    -- if userid == nil then
    --     print("success")
    -- else
    --     print("fail")
    -- end

    if r2CLogin.Error ~= ErrorCode.ERR_Success then
        if onError ~= nil then onError(r2CLogin.Error) end
    else
        self.loginKey = r2CLogin.Key
        self.permission = r2CLogin.Permission

        local client_data = ClientData:GetInstance()
        -- 创建角色埋点
        if client_data.uid == nil or string.IsNullOrEmpty(tostring(client_data.uid)) then
            client_data:SetAccountInfo(r2CLogin.UId, r2CLogin.Password)
            ChannelManager:GetInstance():CommonCallback(GameEvent.CreateRole)
        end
        client_data:SetAccountInfo(r2CLogin.UId, r2CLogin.Password)
        -- TapDB.setUser(tostring(r2CLogin.UId));
        -- 获取服务器状态
        -- local r2CServers = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Servers,{ Key = r2CLogin.Key })
        self.serverAddress =  "192.168.31.81"
        self.serverPort =  "9001"
        local settings = CS.Game.Instance.settings
        if UNITY_EDITOR then
            if not string.IsNullOrEmpty(settings.serverAddress) then
                self.serverAddress = settings.serverAddress
            end
            if not string.IsNullOrEmpty(settings.serverPort) then
                self.serverPort = settings.serverPort
            end
        else
            self.serverAddress = "192.168.31.81"-- "152.32.190.152"
            self.serverPort =  "9001"
        end

        if client_data.feixiao_server_address ~= nil then
            local splits = string.split(client_data.feixiao_server_address,":")
            self.serverAddress = splits[1]
            self.serverPort = splits[2]
        end        
        
        local r2CServers = 
        {
            RpcId = 0,
            Error = 0,
            ServerInfoList = 
            {
                {
                    ServerId = 1001,
                    IP = self.serverAddress,
                    Port = self.serverPort,
                    StateInfo = 2,
                    DateTime = os.time()
                }
            },
            AccountSrvInfoList = 
            {
                {
                    ServerId = 1001,
                    PlayerNickname = "Ame",
                    PlayerLevel = 2,
                }
            },
        }
        if r2CServers.Error ~= ErrorCode.ERR_Success then
            if onError ~= nil then onError(r2CServers.Error) end
        else
            -- self.ServerInfoList = r2CServers.ServerInfoList
            if onLogin ~= nil then onLogin(r2CServers) end
        end
    end    
end

-- 修改密码
SessionComponent.UpdatePassword = function(self, uid, password, username, onLogin, onError)
    local session = Game.Registry:NewObject(Config.SessionClassName)
    self:Connect(session, self.loginAddress, function ()
        -- 请求登录key
        local rkey, rIv = ChannelManager:GetInstance():GetRKey()
        password= CS.AESHelper.EnCode(password,rkey,rIv)
        username = CS.AESHelper.EnCode(username,rkey,rIv)
        local r2CLogin = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Login,{ UId = uid, Password = password, Username = username})
        if r2CLogin.Error ~= ErrorCode.ERR_Success then
            if onError ~= nil then onError(r2CLogin.Error) end
        else
            self.loginKey = r2CLogin.Key
            ClientData:GetInstance():SetAccountInfo(r2CLogin.UId, r2CLogin.Password)
            if onLogin ~= nil then onLogin() end
        end
        session:Dispose()
    end, function(errorCode)
        if onError ~= nil then onError(errorCode) end
        session:Dispose()
    end)
end

-- 请求登录key，是一个短连接
SessionComponent.RequestKey = function(self, uid, password, onSuccess, onFail)
    local session = Game.Registry:NewObject(Config.SessionClassName)
    -- 连接上之前不允许触发断线重连的情况
    session.OnDisConn = nil
    self:Connect(session, self.loginAddress, function ()
        local rkey, rIv = ChannelManager:GetInstance():GetRKey()
        password= CS.AESHelper.EnCode(password,rkey,rIv)
        local r2CLogin = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Login,
                { UId = uid, Password = password, Sig = CS.GameChannel.ChannelManager.instance.signature})
        if r2CLogin.Error ~= ErrorCode.ERR_Success then
            if onFail ~= nil then onFail(r2CLogin.Error) end
        else
            self.loginKey = r2CLogin.Key
            self.permission = r2CLogin.Permission
            if onSuccess ~= nil then onSuccess() end
        end
        session:Dispose()
    end, function(errorCode)
        if onFail ~= nil then onFail(errorCode) end
        session:Dispose()
    end)
end

-- 登录游戏，是一个长连接
-- 点击登录游戏：首先开始网络连接
---@param self SessionComponent
SessionComponent.EnterGame = function(self, gateAddress, onEnter, onError, reConn)
    -- 如果已经在连接或者重连就不允许继续
    if reConn == 1 and self.longSessionState == LongSessionState.ReConnecting then
        Logger.LogError("EnterGame:current state is ReConnecting")
        return
    end
    if reConn ~= 1 and self.longSessionState == LongSessionState.Connecting then
        Logger.LogError("EnterGame:current state is Connecting")
        return
    end
    if reConn == 1 and Game.Scene.Player == nil then
       --没有玩家信息，不能重连
        Logger.LogError("EnterGame:net error")
        return
    end
    self:CloseLongSession()
    self.longSession = Game.Registry:NewObject(Config.SessionClassName)
    self.longSessionState = reConn == 1 and LongSessionState.ReConnecting or LongSessionState.Connecting
    -- 连接上之前不允许触发断线重连的情况
    self.longSession.OnDisConn = nil
    -- 开始连接，socket必须是断开连接才有用
    self:Connect(self.longSession, gateAddress, function ()
        self:OnConn(self.longSession, gateAddress)

        local uid = "sevensphere"
        if CS.UnityEngine.Application.isEditor then        
            local settings = CS.Game.Instance.settings
            if not string.IsNullOrEmpty(settings.accountId) then
                uid = settings.accountId
            end
            PlayerPrefs.SetString("uid"..ClientData:GetInstance().package_name, uid)
        else
            if ChannelManager:GetInstance():IsSdk() then
                local savedUid = PlayerPrefs.GetString("uid"..ClientData:GetInstance().package_name)
                uid = savedUid
            else
                local savedUid = PlayerPrefs.GetString("uid"..ClientData:GetInstance().package_name)
                if not string.IsNullOrEmpty(savedUid) then
                    uid = savedUid
                else
                    math.randomseed(tostring(os.time()):reverse():sub(1, 7))
                    uid = tostring(math.random(10000000,20000000))
                    PlayerPrefs.SetString("uid"..ClientData:GetInstance().package_name, uid)
                end
            end
        end

        local response, errorCode = coroutine.yieldstart(Game.Scene.Session.CoCall, nil, Game.Scene.Session,
        PROTOCOL.FirstCommunicateReq, {})
        if errorCode ~= 0 then
            -- 连接失败
            self:ExitGame()
            return
        end

        self.Computesha256 = CS.ShaTool.Sha256Tool

        self.channelId = 2
        self.resourceVersion = "TestVersion"
        self.device = "TestDevice"
        self.os = "TestOs"
        
        local channelUid = uid

        local platForm = LoginPlatform.LoginPlatformAndroid

        local cd = ClientData:GetInstance()
        self.appversion = cd.app_version
        local settings = CS.Game.Instance.settings

        if UNITY_EDITOR then
            self.channelId = settings.channelId
            self.appversion = "99.99.99"
            if not string.IsNullOrEmpty(settings.versionId) then
                self.appversion = settings.versionId
            end
        else
            if cd.feixiao_resource_version ~= nil then
                self.resourceVersion = cd.feixiao_resource_version
            end
        end

        local sendSignature = self.channelId .. channelUid .. platForm .. response.magicalString
        local SendMagicCode = self.Computesha256.getHashSha256(sendSignature)

        local splits = string.split(ClientData:GetInstance().res_version, ".")
        if UNITY_EDITOR then
            splits = string.split(settings.versionId, ".")
        end
        local versionCode = tonumber(splits[1])  * 1000000 
        + tonumber(splits[2]) * 1000 
        + tonumber(splits[3])

        local req = {
            channel_id = self.channelId,
            channel_uid = uid,
            signature  = SendMagicCode,
            platform_id = platForm,
            version = versionCode
        }
        -- local loginRsp = coroutine.yieldstart(self.longSession.CoCall,nil, self.longSession,
        --         PROTOCOL.LoginReq, req)
        -- CS.GameChannel.ChannelManager.instance:SetServerId("1")

        -- TimeUtil.SetTimeOffset(loginRsp.gmt_offset)
        
        -- CS.GameChannel.ChannelManager.instance:SetUid(tostring(loginRsp.role_id))
        -- if not Config.MockEnabled then
        --     self.longSession:AddComponent("HeartBeatComponent", self.longSession)
        -- end

        -- if onEnter ~= nil then onEnter() end

        --------------------------------------
        PublicRequest.SendRequest(
            PROTOCOL.LoginReq,
            req,
            function(info, errorCode)
                if errorCode == 0 then
                    CS.GameChannel.ChannelManager.instance:SetServerId("1")

                    TimeUtil.SetTimeOffset(info.gmt_offset)

                    CS.GameChannel.ChannelManager.instance:SetUid(tostring(info.role_id))
                    if not Config.MockEnabled then
                        self.longSession:AddComponent("HeartBeatComponent", self.longSession)
                    end

                    if onEnter ~= nil then onEnter() end
                elseif errorCode == 109 then
                    self.deactiveQueue:clear()
                    local wnd = UIManager:GetInstance():GetWindow(UIWindowNames.UILoad, true)
                    if wnd ~= nil then
                        wnd.View:ClearLoad()
                    end

                    UIUtil.ToolTipSeven(LangUtil.GetSysLang(9), LangUtil.GetSysLang(2226), function()
                        self:ExitGame(0)
                    end)
                else
                    -- 连接失败
                    self:ExitGame()
                    return
                end
            end
        )
    end, function (errorCode)
        -- 连接失败
        if onError ~= nil then onError(errorCode) end
        self:CloseLongSession()
    end)
end

-- 退出登录
SessionComponent.ExitGame = function(self, force)
    self.forceOffLine = force
    self:CloseLongSession()
    self.permission = nil
    self.msgCache:clear()
    EventCenter:OnExitGame()
    coroutine.start(function ()
        coroutine.waituntil(function () return not Game.Scene.SceneComponent:IsLoadingScene() end)
        if Game.Scene:GetComponent("SceneComponent"):GetCurrentScene() == SceneConfig.BattleScene.Name then
            Game.Scene:GetComponent("BattleComponent"):Offline()
        elseif Game.Scene:GetComponent("SceneComponent"):GetCurrentScene() == SceneConfig.LoginScene.Name then
            local view = UIManager:GetInstance():GetWindow(UIWindowNames.UISsLogin).View
            if view ~= nil then
                view:OffLine()
            end
        else
            Game.Scene.SceneComponent:SwitchScene(SceneConfig.LoginScene)
            Game.Scene:GetComponent("GuideComponent"):EndGuide()
        end
    end)
end

-- 玩家连接并登录正常
SessionComponent.OnConn = function(self, session)
    -- 只有在正在连接状态才能到连接状态
    if self.longSessionState ~= LongSessionState.Connecting and self.longSessionState ~= LongSessionState.ReConnecting then
        Logger.LogError("SessionComponent.OnConn: current state is not LongSessionState.Connecting or ReConnecting")
        return
    end
    self.longSessionState = LongSessionState.Connected
    -- socket异常断开
    session.OnDisConn = function(isConn) self:OnDisConn(isConn) end
    -- 绑定心跳检测
    --session:AddComponent("HeartBeatComponent", session)
end

SessionComponent.CloseLongSession = function(self)
    if self.longSession then
        self.longSession:RemoveComponent("HeartBeatComponent")
        self.longSession:Dispose()
    end
    self.longSessionState = LongSessionState.DisConnected
    self.longSession=nil
end

-- 断线了（通讯异常）
SessionComponent.OnDisConn = function(self)
    -- 只有在连接状态才能通讯异常
    if self.longSessionState ~= LongSessionState.Connected then
        Logger.LogError("SessionComponent.OnDisConn: current state is not LongSessionState.Connected")
        return
    end
    -- 设置断线状态
    self:CloseLongSession()
    -- 请求玩家数据时：直接报错 不重连
    if self.loadingGameError then
        self.loadingGameError(ErrorCode.ERR_SocketError)
        return
    end
    -- 断线了停止派发消息
    EventCenter:OnExitGame()
    -- 启动重连
    self:StartReConn()
end

SessionComponent.StartReConn = function(self)
    self:ActiveLoad(LangUtil.GetSysLang(1009), LoadMode.Cat, "StartReconn")
    self:ReConnect(5, function ()
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat, "StartReconn")
        self:OnReConnSuccess()
    end, function()
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat, "StartReconn")
        self:OnReConnFail()
    end)
end

-- OnLongReConn:断线重连: 请求key，连接socket，login
SessionComponent.ReConnect = function(self, times, onSuccess, onFail)
    local reConnNum = times
    local uid = ClientData:GetInstance().uid
    local password = ClientData:GetInstance().password
    local serverAddress = ClientData:GetInstance().server_address
    coroutine.start(function ()
        for i = 1, reConnNum do
            local conn = 0
            -- 先获取key
            -- self:RequestKey(uid, password, function()
            --     conn = 1
            -- end, function(msg)
            --     conn = -1
            -- end)
            -- coroutine.waituntil(function() return conn ~= 0 end)

            -- lijunyan: 重连暂时跳过获取key的步骤
            conn = 1
            coroutine.waitforframes(1)
            if conn == 1 then
                -- 重新登录游戏
                conn = 0
                self:EnterGame(serverAddress, function()
                    conn = 1
                end, function()
                    conn = -1
                end, 1)
                coroutine.waituntil(function() return conn ~= 0 end)
                coroutine.waitforframes(1)
                if conn == 1 then
                    if onSuccess then onSuccess() end
                    return
                end
            end
            coroutine.waitforseconds(2)
        end
        if onFail then onFail() end
    end)
end

-- 重连失败，强制退出
SessionComponent.OnReConnFail = function(self)
    UIUtil.ToolTipFirst({
        title = LangUtil.GetSysLang(9),
        message = LangUtil.GetSysLang(3068),
        cancenSysLangKsy = 533,
        callBack = function()
            self:StartReConn()

        end,
        cancelCallBack = function() self:ExitGame(0) end,
        hideCloseBtn = true,
    })
end

-- 重连成功，重新请求
SessionComponent.OnReConnSuccess = function(self)
    Game.Scene.Session:ActiveLoad(LangUtil.GetSysLang(1006), LoadMode.Cat, "OnReConnSuccess")
    self:InitGameData(function ()
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat, "OnReConnSuccess")
        while self.msgCache:size() > 0 do
            if self.longSessionState ~= LongSessionState.Connected then
                return
            end
            local data = self.msgCache:dequeue()
            local msgName
            if data.opcode > OLD_PROTO_ID_START then
                msgName = OuterOpcode.Code2Name[data.opcode]
            else
                msgName = protoMessages[data.opcode]
            end
            -- 老版心跳包没有回复，直接调用session.send发送的，无需走缓存断线重发逻辑
            -- 现在心跳包有回复了，所以这里跳过
            if data.opcode ~= PROTOCOL.PingReq and data.opcode ~= PROTOCOL.FirstCommunicateReq and data.opcode ~= PROTOCOL.LoginReq then
                print("<color=green>ReCall: </color> opcode:"..msgName.."pbMsg:"..table.dump(data.pbMsg))
                self.longSession:ReCall(data.rpcId, data.opcode, data.pbMsg, data.callback, data.loadType)
            end
        end
        -- 处理推送消息
        EventCenter:DispatcherMessages()
    end, function (error) -- 获取玩家数据失败
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat, "OnReConnSuccess")
        self.reConnTimes = self.reConnTimes + 1
        if self.reConnTimes > 2 then
            UIUtil.ToolTipSeven(LangUtil.GetSysLang(9), LangUtil.GetServerError(error), function()
                self:ExitGame(0)
            end)
        else
            -- 启动重连
            self:StartReConn()
        end
    end)
end

-- 需要重连，缓存需要重连的信息
SessionComponent.CacheMessage = function(self, data)
    if data.opcode == PROTOCOL.PingReq or data.opcode == PROTOCOL.FirstCommunicateReq or data.opcode == PROTOCOL.LoginReq then
        return
    end
    
    -- 断线状态或者拉取数据时不缓存消息
    if self.longSessionState == LongSessionState.DisConnected or self.loadingGameError ~= nil then
        return
    end
    local temp = {}
    while self.msgCache:size() > 0 do
        table.insert(temp, self.msgCache:dequeue())
    end
    for i = #temp, 1, -1 do
        self.msgCache:enqueue(temp[i])
    end
    if table.any(temp, function (v) return v.rpcId == data.rpcId end) then
        return
    end
    self.msgCache:enqueue(data)
end

-- LongSend:发送消息不管接收
SessionComponent.Send = function(self, opcode, pbMsg)
    if self.longSessionState ~= LongSessionState.Connected then
        Logger.LogError("it is not connected when send msg")
        return
    end
    self.longSession:Send(opcode, pbMsg)
end

-- LongAysnCall:最好不用异步方式，网络不好的情况下谁知道什么时候返回消息，可成功可失败
SessionComponent.Call = function(self, opcode, pbMsg, callback)
    coroutine.start(function()
        if self.longSessionState == LongSessionState.DisConnected or self.longSessionState == LongSessionState.Connecting then
            callback({Error = ErrorCode.ERR_SocketError})
            return
        end
        if self.longSessionState == LongSessionState.ReConnecting then
            coroutine.waituntil(function () return self.longSessionState ~= LongSessionState.ReConnecting end)
        end
        if self.longSessionState == LongSessionState.DisConnected then
            callback({Error = ErrorCode.ERR_SocketError})
            return
        end
        self.longSession:Call(opcode, pbMsg, callback)
    end)
end

-- LongWaitCall：协程阻塞式发送接收消息，必须有返回
SessionComponent.CoCall = function(self, opcode, pbMsg, loadType)
    -- 正在拉取玩家数据的时候掉线了
    if self.longSessionState ~= LongSessionState.Connected and self.loadingGameError then
        return {Error = ErrorCode.ERR_SocketError}
    end
    if self.longSessionState ~= LongSessionState.Connected then
        -- 等待连接好是因为避免有的通讯必须返回成功
        coroutine.waituntil(function () return self.longSessionState == LongSessionState.Connected end)
    end
    -- 正常通讯
    return self.longSession:CoCall(opcode, pbMsg, loadType)
end

-- 必须返回成功，失败则强制重连（如战斗结算失败） ***拉取玩家数据不要用这个***
SessionComponent.CoSafeCall = function(self, opcode, pbMsg, loadType)
    if self.longSessionState ~= LongSessionState.Connected then
        -- 等待连接好是因为避免有的通讯必须返回成功
        coroutine.waituntil(function () return self.longSessionState == LongSessionState.Connected end)
    end
    -- 该消息超时或者socket断开，则不会返回消息，自动启动断线重新发送；
    -- 如果服务器返回的是错误：没办法
    return self.longSession:CoCall(opcode, pbMsg, loadType)
end

-- tapDB 上报重置和自定义事件测试代码
local function Test()
    local properties = {}
    properties["#abc"]= 123;
    properties["#def"] = "xyz";
    properties["#xyz"] = "中文";
    -- TapDB.trackEvent("#eventCode", properties);
    --注意这个地方的货币类型固定用人民币，不然会不准确，会根据汇率变化而波动
    --订单号  产品名称  多少钱（单位分） 货币类型   充值渠道
    -- TapDB.onChargeSuccess("order03", "iap", 100, "CNY", "Apple Pay");
end

-- 1.点击登录
--     1）请求玩家数据失败 => 网络或数据错误 => 重新点击登录
--     2）登录成功
--         1）正常连接 => nothing
--         2）异常断线 => TODO:静默重连,检测网络状态
--             1）重连失败 => 提示失败，退出登录
--             2）重连成功 => 请求玩家数据
--                 1）请求数据失败 => 网络或数据错误 => 退出登录
--                 2）请求成功 => 重新请求缓存通讯，同步推送的数据
--         3）被挤下线 => 强行退出，清空该玩家游戏组件
--         4）退出登录 => 强行退出，清空该玩家游戏组件
SessionComponent.InitGameData = function(self, onInit, onError)
    self.loadingGameError = onError
    -- 获取玩家数据
    -- local request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil, Game.Scene.Session,
    --         OuterOpcode.Name2Code.ETModel_C2M_PlayerInfo, {})
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end

    ---------------------------------
    local request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil, Game.Scene.Session,
    PROTOCOL.RoleInfoReq, {})

    DayUpdate = 1
    ----2023 玩家信息

    -- 断线重连就更新玩家数据   否则创建玩家数据
    ---@type Player
    local player
    if Game.Scene.Player ~= nil then
        player = Game.Scene.Player
        player:RefreshInfo(request)
    else
        player = Game.Registry:NewObject("Player", request)
    end
    Game.Scene:GetComponent("PlayerComponent").Player = player
    Game.Scene:SetPlayer(player)
    player.AuthLevel = self.permission

    -- 同步服务器时间
    local request = coroutine.yieldstart(TimeUtil.CoLoadData,nil, TimeUtil)
    Logger.Log("TimeUtil.CoLoadData : "..request.Error)
    if request == nil or request.Error ~= ErrorCode.ERR_Success then
        if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
        self.loadingGameError = nil
        Logger.Log("TimeUtil.CoLoadData : return")
        return
    end

    Game.Scene:GetComponent("PlayerComponent"):buffTime() -- 断线重连无法同步

    -- **给玩家添加组件** 断线重连 组件重新绑定 数据更新
    local safeAddComponent = function (componentName)
        local component = player:GetComponent(componentName)
        if component ~= nil then
            return component
        end
        return player:AddComponent(componentName)
    end

    safeAddComponent("ExpeditionComponent")

    -- local storyComponent = safeAddComponent("StoryComponent") --主线需改动
    -- request = coroutine.yieldstart(storyComponent.CoLoadData,nil,storyComponent)
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end
    -- request = coroutine.yieldstart(storyComponent.CoLoadRoadData, nil, storyComponent)
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end

    -- local sevenStarComponent = safeAddComponent("SevenStarComponent") --七星需改动
    -- request = coroutine.yieldstart(sevenStarComponent.CoLoadData,nil,sevenStarComponent)
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return   
    -- end

    -- local cc = safeAddComponent("ChallengeComponent") --挑战本
    -- request = coroutine.yieldstart(cc.CoLoadData,nil,cc)
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end

    ---@type FightSoulComponent
    local fightSoulComponent = safeAddComponent("FightSoulComponent")
    ---@type protocol.FightSoulResp
    local fightSoulReq = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
            PROTOCOL.FightSoulReq, {})
    fightSoulComponent:UpdateBagCapacity(fightSoulReq.bag_capacity)
    for _,v in ipairs(fightSoulReq.fight_souls) do
        fightSoulComponent:Add(Game.Registry:NewObject("FightSoul", {
            uid = v.uid,
            cid = v.cid,
            exp = v.exp,
            level = v.level,
            mergeLevel = v.merge_level,
            isLocked = v.locked
        }),true)
    end

    local skinComponent = safeAddComponent("SkinComponent")
    request = coroutine.yieldstart(skinComponent .CoLoadData,nil,skinComponent )
    if request == nil or request.Error ~= ErrorCode.ERR_Success then
        if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
        self.loadingGameError = nil
        return
    end
    ---@type ItemComponent
    local itemComponent = safeAddComponent("ItemComponent")
    request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
            PROTOCOL.ItemBagReq, {})
    for _,v in ipairs(request.items) do
        itemComponent:Add(Game.Registry:NewObject("Item", v))
    end



    -- local cardComponent = safeAddComponent("CardComponent")
    -- request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
    --         OuterOpcode.Name2Code.ETModel_C2M_CardInfo, {})
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end
    -- for _,v in ipairs(request.CardInfoList) do
    --     local card = Game.Registry:NewObject("Card",v)
    --     if  card.TemplateId ~= 0 then
    --         card:InitCardComponent()
    --         cardComponent:Add(card,nil,true)
    --     end
    -- end
    -- cardComponent:InitZCardsSkins()

    local recordComponent = safeAddComponent("RecordComponent")
    request = coroutine.yieldstart(recordComponent.CoLoadData,nil,recordComponent)

    ----------------------------------2023新版装备系统--------------------------------------
    local equipComponent = safeAddComponent("EquipComponent")
    request = coroutine.yieldstart(equipComponent.CoLoadData,nil,equipComponent)

    ----------------------------------2023新版角色系统--------------------------------------
    local cardComponent = safeAddComponent("CardComponent")
    request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
    PROTOCOL.CharacterPackInfoReq, {})
    for _,v in ipairs(request.character_pack.characters) do
        local card = Game.Registry:NewObject("Card",v)
        if  card.TemplateId ~= 0 then
            card:InitCardComponent()
            cardComponent:Add(card,nil,true)
        end
    end
    if request.character_pack.skins ~= nil then
        for _,v in ipairs(request.character_pack.skins) do
            cardComponent:AddSkin(v)
        end
    end
    player.MainWife = request.character_pack.main_wife

    cardComponent:InitZCardsSkins()
    ----------------------------------2023新版关卡系统----------------------------------------
    local storyComponent = safeAddComponent("StoryComponent")
    request = coroutine.yieldstart(storyComponent.CoLoadData,nil,storyComponent)
    ----------------------------------2023新版七星系统----------------------------------------
    local sevenStarComponent = safeAddComponent("SevenStarComponent")
    request = coroutine.yieldstart(sevenStarComponent.CoLoadData,nil,sevenStarComponent)
    ----------------------------------2023新版普通资源关卡系统----------------------------------------
    local commonLevelComponent = safeAddComponent("CommonLevelComponent")
    request = coroutine.yieldstart(commonLevelComponent.CoLoadData,nil,commonLevelComponent)
    ------------------------------------------------------------------------------------------------

    local teamComponent = safeAddComponent("TeamComponent")
    UIData.Team = nil
    request = coroutine.yieldstart(teamComponent.CoLoadData,nil,teamComponent)
    if request == nil then
        if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
        self.loadingGameError = nil
        return
    end

    local postBoxComponent = safeAddComponent("PostBoxComponent")
    --request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
    --        OuterOpcode.Name2Code.ETModel_C2M_MailsInfo, {})
    request = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
            PROTOCOL.MailboxInfoReq, {})
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end
    postBoxComponent:InitPost(request.mailbox.mails)

    ----------------------------------2023新版抽卡系统----------------------------------------
    local taskComponent = safeAddComponent("TaskComponent")
    request = coroutine.yieldstart(taskComponent.CoLoadData,nil,taskComponent)
    
    local bossraidComponent = safeAddComponent("BossraidComponent")
    -- request = coroutine.yieldstart(bossraidComponent.CoLoadData,nil,bossraidComponent)
    bossraidComponent:RequestBossraidInfos()

    local friendComponent = safeAddComponent("FriendComponent")
    request = coroutine.yieldstart(friendComponent.CoLoadData,nil, friendComponent)

    local monthCardComponent = safeAddComponent("MonthCardComponent")
    request = coroutine.yieldstart(monthCardComponent.CoLoadData,nil,monthCardComponent)

    ---@type CheckInComponent
    local checkInComponent = safeAddComponent("CheckInComponent")
    request = coroutine.yieldstart(checkInComponent.CoLoadData,nil,checkInComponent)

    local shopComponent = safeAddComponent("ShopComponent")
    request = coroutine.yieldstart(shopComponent.CoLoadData,nil,shopComponent)
    -----2023商城改版
    -- if request == nil or request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end

    ---@type CompetitionComponent
    local competitionComponent = Game.Scene:GetComponent("CompetitionComponent")
    request = coroutine.yieldstart(competitionComponent.CoLoadData,nil,competitionComponent)

    local passComponent = safeAddComponent("PassComponent")
    request = coroutine.yieldstart(passComponent.CoLoadData,nil,passComponent)
    
    ---@type GameEventComponent
    local gameEventComponent = safeAddComponent("GameEventComponent")
    request = coroutine.yieldstart(gameEventComponent.CoLoadData,nil,gameEventComponent)
    -----------------------------------------------------------------

    -- local recordComponent = safeAddComponent("RecordComponent")
    -- request = coroutine.yieldstart(recordComponent.CoLoadData,nil,recordComponent)

    safeAddComponent("AfficheComponent")

    local roomComponent = safeAddComponent("RoomComponent");
    roomComponent:UpdateRoomCard(player.BedroomCardId);
    roomComponent:StartSleep(player.LastRoomMalTime);
    roomComponent:StartRest(player.LastRoomRestTime);

    -----------------????????-----------------
    local riskComponent = safeAddComponent("RiskComponent")
    request = coroutine.yieldstart(riskComponent.CoLoadData,nil, riskComponent)
    if request.Error ~= ErrorCode.ERR_Success then
        if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
        self.loadingGameError = nil
        return
    end

    local playerBuffComponent = safeAddComponent("PlayerBuffComponent");
    playerBuffComponent:Set()

    -----------------------------?????????緢???????????---------------------------------------
    local Msg = {}
    Msg.ToId = 99999
    Msg.Message = player.Id.."OnLine"
    Msg.ActorId = 1
    Game.Scene.Session:Send(OuterOpcode.Name2Code.ETModel_C2PF_SendMsg,Msg)

    -----------------------------????????????---------------------------------------
    ---@type GuideComponent
    local guideComponent = Game.Scene:GetComponent("GuideComponent")
    request = coroutine.yieldstart(guideComponent.CoLoadData,nil, guideComponent)

    --------------------------------召唤PickID------------------------
    local recruitComponent = safeAddComponent("RecruitComponent")
    request = coroutine.yieldstart(recruitComponent.CoLoadData,nil,recruitComponent)

    -----------------------------------------------------------------
    local starLightComponent = safeAddComponent("StarLightRebateComponent")
    request = coroutine.yieldstart(starLightComponent.CoLoadData,nil, starLightComponent)
    -- if request.Error ~= ErrorCode.ERR_Success then
    --     if self.loadingGameError ~= nil then self.loadingGameError(request.Error) end
    --     self.loadingGameError = nil
    --     return
    -- end
    
    coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
        PROTOCOL.ClientReadyReq, {})

    self.reConnTimes = 0
    self.loadingGameError = nil
    onInit()

    -- 启用sdk，初始化并补单
    EventCenter:OnEnterGame()
    ChannelManager:GetInstance():OnEnterGame()
end

SessionComponent.LoginTest = function(self, username, gateAddress, tab)
    -- Qoo登录
    local uid = "999"
    local password = ""
    local userKey = username
    username = tostring(username)

    local session = Game.Registry:NewObject(Config.SessionClassName)
    -- 短链接登录账号服
    Logger.Log("Login==========================")
    self:Connect(session, self.loginAddress, function ()
        -- 请求登录key
        local deviceCode = username
        local rkey, rIv = ChannelManager:GetInstance():GetRKey()
        password = CS.AESHelper.EnCode(password,rkey,rIv)
        username = CS.AESHelper.EnCode(username,rkey,rIv)

        local r2CLogin = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Login,{ UId = uid, Password = password, Username = username,DeviceCode = deviceCode})
        if r2CLogin.Error ~= ErrorCode.ERR_Success then
            Logger.LogError("ETModel_C2R_Login: ErrorCode => "..r2CLogin.Error)
        else
            -- 获取验证码 并缓存账号密码到本地
            local loginKey = r2CLogin.Key
            -- 长链接登录游戏服
            local longSession = Game.Registry:NewObject(Config.SessionClassName)
            Logger.Log("EnterGame==========================")
            self:Connect(longSession, gateAddress, function ()
                local gkey, gIv = ChannelManager:GetInstance():GetVKey()
                local req = {
                    Key = loginKey,
                    Reconnect = -1,
                    PassWord = CS.AESHelper.EnCode( r2CLogin.Password,gkey,gIv),
                    ResVersion = ClientData:GetInstance().res_version
                }
                local g2CLoginGate = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2G_LoginGate, req)
                if g2CLoginGate.Error ~= ErrorCode.ERR_Success then
                    Logger.LogError("ETModel_C2G_LoginGate: ErrorCode => "..g2CLoginGate.Error)
                    coroutine.start(function ()
                        coroutine.waitforseconds(1)
                        self:LoginTest(userKey, gateAddress, tab)
                        longSession:Dispose()
                    end)
                else
                    local request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2M_PlayerInfo, {})
                    request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2G_ServerDate, {})
                    request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2M_StoryInfo, {})
                    local msg = {State = 0, IsJoin = 0,ActorId=2}
                    request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2PM_AbyssMonsterInfo, msg)
                    longSession:Dispose()

                    -- 登录次数   账号数据缓存
                    if tab[userKey] == nil then tab[userKey] = 0 end
                    tab[userKey] = tab[userKey] + 1
                    if tab[userKey] < self.testLoginNum then
                        self:LoginTest(userKey, gateAddress, tab)
                    end
                    local txt = cjson.encode(tab)
                    local path = CS.AssetBundles.AssetBundleUtility.GetLocalPersistentDataPath("ServerText.json")
                    CS.GameUtility.SafeWriteAllText(path, txt)
                end
            end, function (errorCode)
                Logger.LogError("EnterGame Connect Error => "..errorCode)
                longSession:Dispose()
            end)
        end
        session:Dispose()
    end, function(errorCode)
        Logger.LogError("Login Connect Error => "..errorCode)
        session:Dispose()
    end)
end

-- 服务器测试： 
-- count number: 测试账号数量
-- num number: 每个账号登入登出的次数
-- gateAddress string: Ip:端口号
-- useCache bool: true: 缓存有足够数量的账号就不注册    false:全部注册新号
SessionComponent.OneThousandAccountLogin = function(self, count, num, gateAddress, useCache)
    self.testLoginNum = num
    -- 加载缓存中的账号
    local path = CS.AssetBundles.AssetBundleUtility.GetLocalPersistentDataPath("ServerText.json")
    local txt = CS.GameUtility.SafeReadAllText(path)
    if string.IsNullOrEmpty(txt) then txt = "{}" end
    local tab = cjson.decode(txt)
    
    -- 生成一个username
    local userName = nil
    if table.count(tab) <= 0 then
        userName = 200000014
    else
        userName = table.count(tab) + 1
    end
    table.walk(tab, function (k, v) tab[k] = 0 end)

    -- 全部注册新号
    if not useCache then
        for i = 1, count do
            self:LoginTest(userName, gateAddress, tab)
            userName = userName + 1
        end
        return
    end
    
    -- 使用缓存中的账号，缓存不够则使用新号
    if table.count(tab) < count then
        table.walk(tab, function (k, v)
            self:LoginTest(k, gateAddress, tab)
        end)
        local remainCount = count - table.count(tab)
        for i = 1, remainCount do
            self:LoginTest(userName, gateAddress, tab)
            userName = userName + 1
        end
    else -- 已经有缓存的不重新注册了
        local index = 0
        table.walk(tab, function (k, v)
            if index <= count then
                index = index + 1
                self:LoginTest(k, gateAddress, tab)
            end
        end)
    end
end

-- 测试用：1个账号同时1000次登录
SessionComponent.OneAccountLoginThousand = function(self)
    local count = 100 -- 同时登录多少次
    --local gateAddress = "8.218.35.58:10011"
    local gateAddress = {"10.6.2.26:10011","10.6.2.26:10012"}
    local path = CS.AssetBundles.AssetBundleUtility.GetLocalPersistentDataPath("loginText.json")
    local txt = CS.GameUtility.SafeReadAllText(path)
    if string.IsNullOrEmpty(txt) then txt = "{}" end
    local tab = cjson.decode(txt)
    local loginTest = function(self, uid, password)
        local session = Game.Registry:NewObject(Config.SessionClassName)
        -- 短链接登录账号服
        self:Connect(session, self.loginAddress, function ()
            local r2CLogin = coroutine.yieldstart(session.CoCall,nil, session, OuterOpcode.Name2Code.ETModel_C2R_Login,{ UId = uid, Password = password, Username = ""})
            if r2CLogin.Error ~= ErrorCode.ERR_Success then
                Logger.LogError("ETModel_C2R_Login: ErrorCode => "..r2CLogin.Error)
            else
                -- 获取验证码 并缓存账号密码到本地
                local loginKey = r2CLogin.Key
                tab[tostring(r2CLogin.UId)] = r2CLogin.Password
                txt = cjson.encode(tab)
                CS.GameUtility.SafeWriteAllText(path, txt)
                Logger.LogError("Test Uid:"..r2CLogin.UId.."   ".."Password:"..r2CLogin.Password)
                -- 长链接登录游戏服
                for i = 1, count do
                    local longSession = Game.Registry:NewObject(Config.SessionClassName)
                    self:Connect(longSession, gateAddress[i%2+1], function ()
                        local req = {
                            Key = loginKey,
                            Reconnect = -1,
                            PassWord = r2CLogin.Password,
                            ResVersion = ClientData:GetInstance().res_version
                        }
                        local g2CLoginGate = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2G_LoginGate, req)
                        if g2CLoginGate.Error ~= ErrorCode.ERR_Success then
                            Logger.LogError("ETModel_C2G_LoginGate: ErrorCode => "..g2CLoginGate.Error)
                            longSession:Dispose()
                        else
                            Logger.LogError("EnterGame Success==========================")
                            local request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2M_PlayerInfo, {})
                            if request.Error == ErrorCode.ERR_Success then
                                Logger.LogError("ETModel_C2M_PlayerInfo Success==========================")
                            end
                            request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2G_ServerDate, {})
                            if request.Error == ErrorCode.ERR_Success then
                                Logger.LogError("ETModel_C2G_ServerDate Success==========================")
                            end
                            request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2M_StoryInfo, {})
                            if request.Error == ErrorCode.ERR_Success then
                                Logger.LogError("ETModel_C2M_StoryInfo Success==========================")
                            end
                            local msg = {State = 0, IsJoin = 0,ActorId=2}
                            request = coroutine.yieldstart(longSession.CoCall,nil, longSession, OuterOpcode.Name2Code.ETModel_C2PM_AbyssMonsterInfo, msg)
                            if  request.Error == ErrorCode.ERR_Success then
                                Logger.LogError("ETModel_C2PM_AbyssMonsterInfo Success==========================")
                            end
                            longSession:Dispose()
                        end
                    end, function (errorCode)
                        Logger.LogError("EnterGame Connect Error => "..errorCode)
                        longSession:Dispose()
                    end)
                end
            end
            session:Dispose()
        end, function(errorCode)
            Logger.LogError("Login Connect Error => "..errorCode)
            session:Dispose()
        end)
    end
  
    if table.count(tab) <= 0 then
        loginTest(self, "777")
    else
        local isLogin = false
        table.walk(tab, function (k, v)
            if isLogin then return end
            isLogin = true
            loginTest(self, k, v)
        end)
    end
end

SessionComponent.Awake = Awake
SessionComponent.Update = Update

return SessionComponent