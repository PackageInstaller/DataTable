---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by daiyi.
--- DateTime: 2019/4/2 14:21
---

local protoMessages = require("Protobuf.proto_messages")

local Session = BaseClass("Session",Entity)
local base = Entity

OLD_PROTO_ID_START = 1000000

if TcpState == nil then
    TcpState = {
        Connected = 1,
        Connecting = 2,
        DisConnected = 3,
        TimeOut2 = 4,
        Dispose = 5,
    }
end

-- local function Pack(self,opcode,pbMsg)
--     local pbBytes = assert(pb.encode(OuterOpcode.Code2Name[opcode],pbMsg),"pb encode err:"..cjson.encode(pbMsg))
--     local output = ""
--     --output = output..string.pack("=B", 0)
--     output = output..string.pack("=H", opcode)
--     output = output..pbBytes
--     return output
-- end

-- local function Unpack(self,recvBytes)
--     local index = 1
--     --local flag = string.unpack("=B", recvBytes, index)
--     --index=index+1
--     local opcode = string.unpack("=H", recvBytes, index)
--     index=index+2
--     local pbBytes = string.sub(recvBytes, index)
--     local pbMsg = assert(pb.decode(OuterOpcode.Code2Name[opcode],pbBytes),"pb decode err:"..OuterOpcode.Code2Name[opcode])
--     return opcode,pbMsg
-- end

local function Pack(self, msgId, msg)
    local pbMsg = nil
    if msg ~= nil then
        pbMsg = assert(pb.encode(protoMessages[msgId], msg))
    end
    local c2sMsg = {
        proto_id = msgId,
        message_no = self.rpc_id,
        data = pbMsg
    }
    local pbC2sMsg = assert(pb.encode("protocol.C2SMessage", c2sMsg))
    return pbC2sMsg
end

local function Unpack(self, recvBytes)
    local s2cMsg = assert(pb.decode("protocol.S2CMessage", recvBytes))
    if s2cMsg == nil then
        Logger.LogError("received invalid server message, s2cMsg is nil")
        return
    end

    local msgId = s2cMsg.proto_id
    if msgId == nil or msgId == 0 then
        Logger.LogError("received invalid server message, proto id is nil or zero")
    end

    TimeUtil.SetServerTime(s2cMsg.server_time)

    local msg = assert(pb.decode(protoMessages[msgId], s2cMsg.data))
    return msgId, msg, s2cMsg.message_no, s2cMsg.error_code
end

local function OnRecv(self,recvBytes)
    -- message_no 作为 rpc_id使用
    local opcode, pbMsg, msgNo, errorCode = Unpack(self,recvBytes)
    if(msgNo == nil or msgNo == 0)then
        self.callback_queue:enqueue(function ()
            if string.len(recvBytes) < 1024 then
                Logger.Log("<color=green>[Dispatcher] </color>"..protoMessages[opcode].." "..table.dump(pbMsg))
            else
                Logger.Log("<color=green>[Dispatcher] </color>"..protoMessages[opcode].."...")
            end
            self.message_dispatcher:Handle(opcode, pbMsg) 
        end)
        return
    end
    if opcode ~= PROTOCOL.PingResp then
        if string.len(recvBytes) < 1024 then
            Logger.Log("<color=green>[Recv] </color>"..msgNo .. "     " .. protoMessages[opcode].." "..table.dump(pbMsg))
        else
            Logger.Log("<color=green>[Recv] </color>"..msgNo .. "     " .. protoMessages[opcode].."...")
        end
    end
    if errorCode ~= 0 and errorCode ~= nil then
        Logger.LogError("Session - OnRecv()   " .. " opcode:" .. opcode .. ", errorCode:" .. errorCode)
    end
    self:HandleMessage(pbMsg, msgNo, errorCode)
end

-- 统一消息处理
Session.HandleMessage = function(self, msg, msgNo, errorCode)
    -- message_no 作为 rpc_id使用
    local data = self.request_callback[msgNo]
    if data == nil then return end
    local callback = data.callback
    if callback == nil then return end
    self.request_callback[msgNo] = nil
    callback(msg, errorCode)
    self:DeActive(data, msgNo)
end

Session.DeActive = function(self, data, msgNo)
    if data.loadType.loadMode == LoadMode.Mask then
        Game.Scene.Session:DeActiveLoad(LoadMode.Mask, "proto_"..msgNo)
    elseif data.loadType.loadMode == LoadMode.Cat then
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat, "proto_"..msgNo)
    end
    if data.isTimeOut2 then
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat, "proto_"..msgNo)
    end
end

local function OnErr(self,err)
    --print("<color=red>Socket Error:</color>"..err:ToString())
    self.callback_queue:enqueue(function () 
        --print("<color=green>Socket Error:</color>"..err:ToString())
        self:ChangeState(TcpState.DisConnected)
    end)
end

-- 创建一个连接实体，用来网络连接
Session.Awake = function (self)
    base.Awake(self)
    self.cs_network_component = CS.HiSocket.NetworkComponent.Instance
    self.callback_queue = Queue.New()
    self.is_queue_busy = false
    self.rpc_id = 0
    self.request_callback = {}
    self.message_dispatcher = Game.Scene:GetComponent("MessageDispatcherComponent")

    self.connectTimeout = 3
    self.OnConnError = nil -- 连接异常
    self.OnConn = nil -- 连接上
    self.OnDisConn = nil -- socket异常
    
    self:ChangeState(TcpState.DisConnected)
end

-- 销毁连接实体，断开网络连接，这个就再也没啥用了
Session.Dispose = function (self)
    base.Dispose(self)
    self:DisConnect() -- 断开连接

    self.cs_network_component = nil
    self.callback_queue:clear() -- 广播消息队列也不处理了
    self.is_queue_busy = false
    self.rpc_id = 0
    table.walk(self.request_callback, function (k, v) -- 发送的消息没有返回的都按错误处理
        -- 彻底断开连接，消息就不管了
        self:HandleMessage({RpcId = k, Error = ErrorCode.ERR_SocketError, callback = v.callback})
    end)
    self.request_callback = {}

    self.OnDisConn = nil
    self:ChangeState(TcpState.Dispose)
end

-- Socket连接: 1.正常连接  2.连接超时 3.Error
Session.Connect = function(self, ip, port, onConn, onError)
    if not self:ChangeState(TcpState.Connecting) then -- 当前状态切换到连接状态
        if onError ~= nil then onError(ErrorCode.ERR_SocketError) end
        return
    end
    local t_channel = self.cs_network_component:Create(ip, port)
    self.t_channel = t_channel
    self.t_channel.RecvHandle = Bind(self, OnRecv)
    self.t_channel.ErrHandle = Bind(self, OnErr)
    self.OnConnError = onError
    self.OnConn = onConn
    local isTimeOut = false
    coroutine.start(function ()
        coroutine.start(function ()
            coroutine.waitforseconds(self.connectTimeout) -- 连接超时时间
            isTimeOut = true
        end)
        coroutine.waituntil(function () -- 返回连接信息，可能连接可能没连接
            return isTimeOut or self:IsConnected() or self.tcpState ~= TcpState.Connecting
        end)
        if self:IsConnected() then
            self:ChangeState(TcpState.Connected) -- 切换到连接状态
            return
        end
        if isTimeOut then
            self:ChangeState(TcpState.DisConnected) -- 切换到断开状态
        end
    end)
end

Session.DisConnect = function(self)
    self.OnConnError = nil
    self.OnDisConn = nil
    self.t_channel:Dispose()
    self.t_channel.RecvHandle = nil
    self.t_channel.ErrHandle = nil
    self.tcpState = TcpState.DisConnected
end

Session.ChangeState = function (self, state)
    if self.tcpState == nil then -- 初始化
        print("<color=green>session: socket init: </color>"..state)
        self.tcpState = state
        return true
    end
    if state == TcpState.Dispose then -- 销毁
        print("<color=red>session: socket dispose</color>")
        self.tcpState = nil
        return true
    end
    if state == TcpState.Connecting then -- 连接socket必须是未连接状态去连接
        if self.tcpState ~= TcpState.DisConnected then -- 阻断瞎连接
            print("<color=red>session: cannot connecting in :</color>"..self.tcpState)
            return false
        end
        self.tcpState = state
        return true
    end
    if state == TcpState.Connected then -- 只有正在连接状态才能够切换到连接状态
        local curState = self.tcpState
        self.tcpState = state
        if curState ~= TcpState.Connecting then
            print("<color=green>session: cannot connected in :</color>"..curState)
            self.tcpState = TcpState.DisConnected
            local connError = self.OnConnError
            self.OnConnError = nil
            if connError ~= nil then connError(ErrorCode.ERR_SocketError) end
            self:DisConnect()
            return false
        end
        local conn = self.OnConn
        self.OnConnError = nil
        self.OnConn = nil
        if conn ~= nil then conn() end
        return true
    end
    if state == TcpState.DisConnected then -- 异常断开
        local curState = self.tcpState
        if curState == TcpState.DisConnected then
            return false
        end
        self.tcpState = state
        if curState == TcpState.Connecting then -- 连接的时候没连接上
            print("<color=green>session: connecting: socket connecting failed</color>")
            coroutine.start(function ()
                if self.OnConnError ~= nil then self.OnConnError(ErrorCode.ERR_SocketError) end
            end)
        elseif curState == TcpState.Connected then -- 连接的时候异常断开，或超时
            print("<color=green>session: connected: socket disconnected or timeout, begin reConn</color>")
            self:ReConnect()
            return
        end
        self:DisConnect()
        return true
    end
    return false
end

-- 问题1：阻塞发送的消息，不能先返回错误，不然重连后再次发送消息就没用了
-- 问题2：loading界面被删除报错 => 该界面不销毁
-- 问题3：断线重连后，服务器需要把主动发送的消息发送过来
-- 问题4：延迟接收到了消息：超过5秒客户端没接收到消息都视为无效
-- 问题5：发送给服务器，过很久才返回

-- 注意：1.请求key，login 是没有重连的
--      2.只有在正常登陆后，才存在请求出错或网络异常断开或超时的情况
--      3.只有正常登陆后才会绑定异常断开的回调
Session.ReConnect = function (self)
    table.walk(self.request_callback, function (k, v)
        -- 消息缓存了，去除响应的加载遮罩
        -- 这是用户登录了，通讯异常
        if self.OnDisConn ~= nil then
            -- 缓存通讯的消息
            self:DeActive(v, k)
            Game.Scene:GetComponent("SessionComponent"):CacheMessage({rpcId = k, opcode = v.opcode, pbMsg = v.pbMsg, callback = v.callback, loadType = v.loadType})
        else -- 这是socket已经连接了，但是请求key或login出现异常，清空缓存返回错误即可
            -- 按通讯错误进行返回
            self:HandleMessage({RpcId = k, Error = ErrorCode.ERR_SocketError, callback = v.callback})
        end
    end)
    self.request_callback = {}
    if self.OnDisConn ~= nil then
        self.OnDisConn() -- 断线了
        self.OnDisConn = nil
        return
    end 
end

Session.Update = function (self)
    if not self.is_queue_busy and self.callback_queue:size()>0 then
        self.is_queue_busy = true
        local callback = self.callback_queue:dequeue()
        coroutine.start(function ()
            callback()
            self.is_queue_busy = false
        end)
    end
end

Session.IsConnected = function (self)
    return self.t_channel.IsConnected
end

local function DebugSend(opcode,pbMsg, rpcId)
    if opcode == OuterOpcode.Name2Code.ETModel_C2G_HeartBeat then return end
    if Authority:GetReportAuth() then
        if opcode ~= PROTOCOL.PingReq then
            if opcode < OLD_PROTO_ID_START then
                print("<color=green>[send] </color>"..rpcId .. "     " .. protoMessages[opcode].." "..table.dump(pbMsg))                
            else
                print("<color=green>[send] </color>"..rpcId .. "     " .. opcode.." "..table.dump(pbMsg))
            end
        end
    end
end

-- 解决问题点：客户端发送消息必须要有返回的情况（类似心跳这种发了就不管的除外，异步的也除外，尽量不要用异步吧除非不用管什么时候返回消息）
-- Send：客户端发送消息，启动遮罩，避免用户再次操作
-- 1.正常返回消息：=> 移除遮罩（网络状况良好，服务器返回错误也是正常的）
-- 2.没正常返回消息：
--      1. 两秒内：socket异常：=> 断开socket连接，缓存所有正在发送的消息，启动断线重连（断网，服务器宕机，客户端心跳停止过长 等）
--      2. 两秒内：socket未异常
--            1。两秒时：=> 调用加载猫
--            2. 超过两秒未超过五秒：
--                  1.socket异常：=> 断开socket连接，缓存所有正在发送的消息，关闭加载猫，启动断线重连
--                  2.socket未异常：
--                        1.五秒时：=> 断开socket连接，缓存所有正在发送的消息，关闭加载猫，启动断线重连
Session.Send = function (self, opcode, pbMsg, rpcId)
    -- if true then
    if opcode < OLD_PROTO_ID_START then
        local sendBytes = Pack(self, opcode, pbMsg)
        DebugSend(opcode, pbMsg, rpcId)
        self.t_channel:Send(sendBytes)
    else
        if rpcId == nil then
            rpcId = opcode
        end
        if opcode < OLD_PROTO_ID_START then
            print("<color=green>[mockSend] </color>"..rpcId .. "     " .. protoMessages[opcode].." "..table.dump(pbMsg))                
        else
            print("<color=green>[mockSend] </color>"..rpcId .. "     " .. opcode.." "..table.dump(pbMsg))
        end
        self:mockSendMsg(opcode, pbMsg, rpcId)
    end
end

Session.mockSendMsg = function(self, opcode, pbMsg, rpcId)
    Logger.Log("mock send " .. opcode)
    local msg = nil
    msg = MockManager:GetInstance():HandleMsg(opcode, pbMsg)

    if msg == nil then
        msg = 
        {
            RpcId = pbMsg.RpcId,
            Error = 0,
        }
    end

    local data = self.request_callback[rpcId]
    if data == nil then
        if rpcId == nil then
            Logger.Log(opcode .. "rpcId为空")
        end
        return
    end
    local callback = data.callback
    if callback == nil then return end
    self.request_callback[msg.RpcId] = nil
    callback(msg, 0)
    self:DeActive(data, msg.RpcId)

end

-- 消息做超时处理
Session.TimeOut = function(self, rpcId, opcode)
    local isTimeOut2 = false
    local isTimeOut5 = false
    coroutine.start(function ()
        coroutine.waitforunscaledseconds(2)--0.05
        isTimeOut2 = true
        coroutine.waitforunscaledseconds(10)--0.1
        isTimeOut5 = true
    end)
    coroutine.waituntil(function ()
        -- 超时时限内接受到了消息，则无需做超时记录
        if self.request_callback[rpcId] == nil then
            return true
        end
        -- 2秒没接受到消息，就启动加载猫不允许用户再操作了
        if isTimeOut2 and not isTimeOut5 then
            if not self.request_callback[rpcId].isTimeOut2 then
                self.request_callback[rpcId].isTimeOut2 = true
                print("<color=green>timeout2: load cat</color> " .. rpcId)
                Game.Scene.Session:ActiveLoad(LangUtil.GetSysLang(3066), LoadMode.Cat, "proto_"..rpcId)
            end
            return false
        end
        -- 5秒没有接受到消息，断开连接
        if isTimeOut5 then
            self:ChangeState(TcpState.DisConnected)
            return true
        end
    end)
end

-- 回调的方式调用
Session.Call = function (self, opcode, pbMsg, callback, loadType)
    if self.tcpState ~= TcpState.Connected then
        print("<color=green>Can not [send] When DisConn</color>"..self.tcpState..opcode.." "..table.dump(pbMsg))
        if callback ~= nil then callback({Error = ErrorCode.ERR_SocketError}) end
        return
    end
    -- 一发送消息就调用加载遮罩
    local loadMsg = loadType == nil and "" or loadType.loadMsg
    local loadMode = loadType == nil and LoadMode.Mask or loadType.loadMode
    loadType = {loadMsg = loadMsg, loadMode = loadMode}
    Game.Scene.Session:ActiveLoad(loadMsg, loadMode, "proto_"..self.rpc_id + 1)
    -- 消息回调
    self.rpc_id = self.rpc_id + 1
    self.request_callback[self.rpc_id] = {opcode = opcode, pbMsg = pbMsg, callback = callback, loadType = loadType}
    if opcode >= OLD_PROTO_ID_START then
        pbMsg.RpcId = self.rpc_id
    end
    -- 发送消息
    self:Send(opcode, pbMsg, self.rpc_id)
    -- 超时处理
    self:TimeOut(self.rpc_id, opcode, pbMsg, callback)
end

-- 重连后继续请求
Session.ReCall = function(self, rpcId, opcode, pbMsg, callback, loadType)
    if self.tcpState ~= TcpState.Connected then
        print("<color=green>Can not [send] When DisConn</color>"..self.tcpState..opcode.." "..table.dump(pbMsg))
        if callback ~= nil then callback({Error = ErrorCode.ERR_SocketError}) end
        return
    end
    -- 一发送消息就调用加载遮罩
    local loadMsg = loadType == nil and "" or loadType.loadMsg
    local loadMode = loadType == nil and LoadMode.Mask or loadType.loadMode
    loadType = {loadMsg = loadMsg, loadMode = loadMode}
    Game.Scene.Session:ActiveLoad(loadMsg, loadMode, "proto_"..self.rpc_id + 1)
    -- 消息回调
    self.rpc_id = self.rpc_id + 1
    rpcId = self.rpc_id
    self.request_callback[rpcId] = {opcode = opcode, pbMsg = pbMsg, callback = callback, loadType = loadType}
    pbMsg.RpcId = rpcId
    -- 发送消息
    self:Send(opcode, pbMsg, rpcId)
    -- 超时处理
    self:TimeOut(rpcId, opcode, pbMsg, callback)
end

-- 尝试用协程的方式模拟await async的调用
Session.CoCall = function (self, opcode, pbMsg, loadType)
    if self.tcpState ~= TcpState.Connected then
        print("<color=green>Can not [send] When DisConn</color>"..self.tcpState..opcode.." "..table.dump(pbMsg))
        return coroutine.yieldbreak({Error = ErrorCode.ERR_SocketError})
    end
    local response, errorCode
    self:Call(opcode, pbMsg, function(_response, _errorCode)
        response = _response
        errorCode = _errorCode
    end, loadType)
    coroutine.waituntil(function () return response ~= nil end)
    return coroutine.yieldbreak(response, errorCode)
end

return Session