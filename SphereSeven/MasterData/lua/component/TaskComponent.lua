---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by win 10.
--- DateTime: 2019/7/11 9:54
--- 任务组件

---@class TaskPack
---@field taskMap table<number, Task>
---@field type number
---@field activityPoint number
---@field recrivedStage number[]
---@field lastRefreshTime number

---@class TaskComponent
---@field taskPacks TaskPack[]
---@field excelData table<number, table<number, number[]>> @ 这里面能查到 就说明有后置. key:type, value:每一类中所有 有后置的任务 ( key:id, value: 一个table 表示后置任务有哪些)
local TaskComponent = BaseClass("TaskComponent", Component)
local base = Component
local this = TaskComponent
local IsSend = false
local IsSend2 = false

local TaskExcel = {
    [TaskType.TaskTypeMain] = Z_TaskMain,
    [TaskType.TaskTypeDaily] = Z_TaskDaily,
    [TaskType.TaskTypeWeekly] = Z_TaskWeekly,
    [TaskType.TaskTypeAchievement] = Z_TaskAchievement,
    [TaskType.TaskTypeGameEvent] = Z_TaskGameEvent,
    [TaskType.TaskTypePass] = Z_PassTask,
}

function this:Awake()
    base.Awake(self)
    self.taskPacks = {}
    self.Tasks = {}

    ---@type HintComponent
    self.hintComponent = Game.Scene:GetComponent("HintComponent")
    self.taskHint = self.hintComponent.Task
    self.taskHint:SetCount(0)

    self.AddReqData = {}
    self.CreateReqData={}
    IsSend = true
    IsSend2= true
    for _, v in pairs(TaskType) do
        if v == TaskType.TaskTypeGameEvent then
            self.hintComponent:AddHint("TaskTypeGameEvent")
        elseif v == TaskType.TaskTypePass then
            self.hintComponent:AddHint("TaskTypePass")
        else
            self.taskHint:AddChild(v)
        end
    end

    self.excelData = {}
    self:InitClientData()
end

--- 检查任务是否是最后一个 (是否有后置任务)
---@return boolean @ true: 最后一个. 必须:无前置or前置已领取.  无后置任务or有后置 但是自身未领取
---@param task Task
function this:CheckIsFinal(task)
    if task.config.PreTaskId ~= nil or task.config.PreTaskId ~= 0 then
        -- 有前置 并且未领取的话 就是false
        local preTask = self.taskPacks[task.type].taskMap[task.config.PreTaskId]
        if preTask ~= nil and preTask.status ~= TaskStatus.TaskStatusReceived then
            return false
        end
    end

    -- 下面不需要关心前置了

    if task.status ~= TaskStatus.TaskStatusReceived then
        -- 自身未领取 显示自身 true
        return true
    end

    -- 如果已领取, 看后置有没有, 有的话就是false

    if self.excelData[task.type] == nil then
        return true
    end
    if self.excelData[task.type][task.Id] == nil then
        return true
    end

    for _, nextTaskId in pairs(self.excelData[task.type][task.Id]) do
        -- 后置任务存在的话 就不行
        if self.taskPacks[task.type].taskMap[nextTaskId] ~= nil then
            return false
        end
    end
    return true
end

---@return Task[]
function this:GetShowList(type)
    if self.taskPacks[type] == nil then
        Logger.LogError("任务类型不存在" .. type)
        return {}
    end

    local tasks = {}
    for _, value in pairs(self.taskPacks[type].taskMap) do
        if self:CheckIsFinal(value) then
            table.insert(tasks, value)
        end
    end
    return tasks
end

function this:GetTasks(type, taskGroup)
    local tasks = self:GetShowList(type)
    if taskGroup == nil then
        return tasks
    else
        local ret = {}
        for index, value in ipairs(tasks) do
            if value.config.Group == taskGroup then
                table.insert(ret, value)
            end
        end
        return ret
    end
end

function this:GetTask(type, taskId)
    if self.taskPacks[type] == nil then
        return nil
    end
    return self.taskPacks[type].taskMap[taskId]
end

function this:InitClientData()
    for type, excel in pairs(TaskExcel) do
        -- 对于每一类任务
        self.excelData[type] = {}
        for _, value in pairs(excel) do
            -- 对于每个任务
            if value.PreTaskId ~= 0 then
                -- 存在前置任务
                if self.excelData[type][value.PreTaskId] == nil then
                    self.excelData[type][value.PreTaskId] = {}
                end
                table.insert(self.excelData[type][value.PreTaskId], value.Id)
            end
        end
    end
end

function this:CoLoadData()
    ---@type protocol.TaskPackResp
    local response = coroutine.yieldstart(Game.Scene.Session.CoCall,nil,Game.Scene.Session,
            PROTOCOL.TaskPackReq, {})

    for _, taskPack in ipairs(response.task_packs) do
        self:UpdateTaskPack(taskPack)
    end

    return coroutine.yieldbreak(response)
end

---@param taskPack protocol.TaskPack @ 直接跟 TaskUpdatePush 共用一个处理( update中多了一个removeds字段 )
function this:UpdateTaskPack(taskPack)
    if self.taskPacks[taskPack.type] == nil then
        self.taskPacks[taskPack.type] = {}
        self.taskPacks[taskPack.type].taskMap = {}
        self.taskPacks[taskPack.type].type = taskPack.type
    end

    if taskPack.removeds ~= nil then
        for _, taskId in pairs(taskPack.removeds) do
            self:RemoveTask(taskPack.type, taskId)
        end
    end

    for _, value in ipairs(taskPack.tasks) do
        self:AddOrUpdateTask(taskPack.type, value.id, value.status, value.progress)
    end

    if taskPack.task_stage ~= nil then
        self.taskPacks[taskPack.type].activityPoint = taskPack.task_stage.activity_point
        self.taskPacks[taskPack.type].recrivedStage = taskPack.task_stage.received_stage
    end

    self.taskPacks[taskPack.type].lastRefreshTime = taskPack.last_refresh_time or self.taskPacks[taskPack.type].lastRefreshTime

    if taskPack.type == TaskType.TaskTypeGameEvent or taskPack.type == TaskType.TaskTypePass then
        ---@type GameEventComponent
        local gameEventComponent = Game.Scene.Player:GetComponent("GameEventComponent")
        if gameEventComponent ~= nil then
            gameEventComponent:RefreshModuleHint(nil, "Task")
        end
    end
end

function this:AddOrUpdateTask(type, id, status, count)
    if self.taskPacks[type].taskMap[id] == nil then
        if type == TaskType.TaskTypeGameEvent then
            self.hintComponent.hints["TaskTypeGameEvent"]:AddChild(id, 0)
        elseif type == TaskType.TaskTypePass then
            self.hintComponent.hints["TaskTypePass"]:AddChild(id, 0)
        else
            if self.taskHint:GetChild(type) == nil then
                self.taskHint:AddChild(type)
            end
            self.taskHint:GetChild(type):AddChild(id, 0)
        end
        
        local task = Game.Registry:NewObject("Task", 
        {
            id = id,
            status = status,
            count = count,
            type = type,
            },
            TaskExcel[type][id]
        )
        self.taskPacks[type].taskMap[id] = task
    else
        self.taskPacks[type].taskMap[id]:UpdateData({
            id = id,
            status = status,
            count = count,
            type = type,
        })
    end
end

function this:RemoveTask(type, taskId)
    if self.taskPacks[type] == nil or self.taskPacks[type].taskMap == nil then
        return
    end
    self.taskPacks[type].taskMap[taskId] = nil
end

function this:Add()
    Logger.LogError("当前接口已失效")
end

function this.LimitTaskIsOpen(self, type, TemplateId)
    Logger.LogError("当前接口已失效")
    return true
end

---领取任务奖励
function this:CompleteTask(id, callback)
    Logger.LogError("当前接口已失效, 出现该报错需要修复")
end

function this.Remove(self,Id)
    self.Tasks[Id] = nil
end

function this.Dispose(self)
    base.Dispose(self)
end

return this