---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by daiyi.
--- DateTime: 2019/4/2 14:21
---
local MockSession = BaseClass("MockSession",Entity)
local base = Entity

-- 统一消息处理
MockSession.HandleMessage = function(self, msg)
    local data = self.request_callback[msg.RpcId]
    if data == nil then return end
    local callback = data.callback
    if callback == nil then return end
    self.request_callback[msg.RpcId] = nil
    callback(msg)
    self:DeActive(data)
end

MockSession.DeActive = function(self, data)
    if data.loadType.loadMode == LoadMode.Mask then
        Game.Scene.Session:DeActiveLoad(LoadMode.Mask)
    elseif data.loadType.loadMode == LoadMode.Cat then
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat)
    end
    if data.isTimeOut2 then
        Game.Scene.Session:DeActiveLoad(LoadMode.Cat)
    end
end

-- 创建一个连接实体，用来网络连接
MockSession.Awake = function (self)
    base.Awake(self)
    self.callback_queue = Queue.New()
    self.is_queue_busy = false
    self.rpc_id = 0
    self.request_callback = {}
end

-- 销毁连接实体，断开网络连接，这个就再也没啥用了
MockSession.Dispose = function (self)
    base.Dispose(self)
    self:DisConnect() -- 断开连接

    self.cs_network_component = nil
    self.callback_queue:clear() -- 广播消息队列也不处理了
    self.is_queue_busy = false
    self.rpc_id = 0
    self.request_callback = {}

    self.OnDisConn = nil
end

-- Socket连接: 1.正常连接  2.连接超时 3.Error
MockSession.Connect = function(self, ip, port, onConn, onError)
    self.isConnected = true
    if onConn ~= nil then
        coroutine.start(onConn)
    end
end

MockSession.DisConnect = function(self)
end

MockSession.Update = function (self)
    if not self.is_queue_busy and self.callback_queue:size()>0 then
        self.is_queue_busy = true
        local callback = self.callback_queue:dequeue()
        coroutine.start(function ()
            callback()
            self.is_queue_busy = false
        end)
    end
end

MockSession.IsConnected = function (self)
    return self.isConnected
end

local function DebugSend(opcode,pbMsg)
    if opcode == OuterOpcode.Name2Code.ETModel_C2G_HeartBeat then return end
    if Authority:GetReportAuth() then
        print("<color=green>[send] </color>"..OuterOpcode.Code2Name[opcode].." "..table.dump(pbMsg))
    end
end

-- 解决问题点：客户端发送消息必须要有返回的情况（类似心跳这种发了就不管的除外，异步的也除外，尽量不要用异步吧除非不用管什么时候返回消息）
-- Send：客户端发送消息，启动遮罩，避免用户再次操作
-- 1.正常返回消息：=> 移除遮罩（网络状况良好，服务器返回错误也是正常的）
-- 2.没正常返回消息：
--      1. 两秒内：socket异常：=> 断开socket连接，缓存所有正在发送的消息，启动断线重连（断网，服务器宕机，客户端心跳停止过长 等）
--      2. 两秒内：socket未异常
--            1。两秒时：=> 调用加载猫
--            2. 超过两秒未超过五秒：
--                  1.socket异常：=> 断开socket连接，缓存所有正在发送的消息，关闭加载猫，启动断线重连
--                  2.socket未异常：
--                        1.五秒时：=> 断开socket连接，缓存所有正在发送的消息，关闭加载猫，启动断线重连
MockSession.Send = function (self, opcode, pbMsg)
    self:mockSendMsg(opcode, pbMsg)
end

MockSession.TimeOut = function(self, rpcId)
    local isTimeOut2 = false
    local isTimeOut5 = false
    coroutine.start(function ()
        coroutine.waitforseconds(2)--0.05
        isTimeOut2 = true
        coroutine.waitforseconds(5)--0.1
        isTimeOut5 = true
    end)
    coroutine.waituntil(function ()
        -- 超时时限内接受到了消息，则无需做超时记录
        if self.request_callback[rpcId] == nil then
            return true
        end
        -- 2秒没接受到消息，就启动加载猫不允许用户再操作了
        if isTimeOut2 and not isTimeOut5 then
            if not self.request_callback[rpcId].isTimeOut2 then
                self.request_callback[rpcId].isTimeOut2 = true
                print("<color=green>timeout2: load cat</color>")
                Game.Scene.Session:ActiveLoad(LangUtil.GetSysLang(3066), LoadMode.Cat)
            end
            return false
        end
        -- 5秒没有接受到消息，断开连接
        if isTimeOut5 then
            self:ChangeState(TcpState.DisConnected)
            return true
        end
    end)
end

-- 回调的方式调用
MockSession.Call = function (self, opcode, pbMsg, callback, loadType)
    local loadMsg = loadType == nil and "" or loadType.loadMsg
    local loadMode = loadType == nil and LoadMode.Mask or loadType.loadMode
    loadType = {loadMsg = loadMsg, loadMode = loadMode}
    Game.Scene.Session:ActiveLoad(loadMsg, loadMode)
    -- 消息回调
    self.rpc_id = self.rpc_id + 1
    self.request_callback[self.rpc_id] = {opcode = opcode, pbMsg = pbMsg, callback = callback, loadType = loadType}
    pbMsg.RpcId = self.rpc_id

    self:Send(opcode, pbMsg)
    self:TimeOut(self.rpc_id, opcode, pbMsg, callback)
end

-- 尝试用协程的方式模拟await async的调用
MockSession.CoCall = function (self, opcode, pbMsg, loadType)
    local response
    self:Call(opcode, pbMsg, function(_response)
        response = _response
    end, loadType)
    coroutine.waituntil(function () return response ~= nil end)
    return coroutine.yieldbreak(response, 0)
end

MockSession.mockSendMsg = function(self, opcode, pbMsg)
    Logger.Log("mock send " .. opcode .. table.dump(pbMsg))
    local msg = nil
    msg = MockManager:GetInstance():HandleMsg(opcode, pbMsg)

    -- 未处理的协议暂时进行简单旧协议回复，好正常进入主界面
    if msg == nil then
        msg = 
        {
            RpcId = pbMsg.RpcId,
            Error = 0,            
        }
    end

    -- 新协议使用message_no作为rpc_id，mock返回的回复msg没有rpc_id
    -- 为兼容旧协议mock，此处为新协议手动添加rpc_id
    if msg.RpcId == nil then
        msg.RpcId = self.rpc_id
    end

    Logger.Log("<color=green>[mock Recv] </color>".. opcode .." "..table.dump(msg))
    local data = self.request_callback[msg.RpcId]
    if data == nil then return end
    local callback = data.callback
    if callback == nil then return end
    self.request_callback[msg.RpcId] = nil
    callback(msg)
    self:DeActive(data)

end

return MockSession